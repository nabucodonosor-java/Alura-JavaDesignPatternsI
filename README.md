# Alura-Java Design Patterns I
- Strategy: em um sistema que envolva muitos cálculos que variam de acordo com um determinado parâmetro o código pode ficar cheio de if e else. O padrão Strategy serve para deixar o código mais coeso onde cada classe tem a sua estratégia específica, utilizando-se de interfaces para evitar acoplamentos altos.
- Chain of Responsability: tem objetivo similar ao padrão strategy, evitar muitos if else e classes que não param de crescer. A diferença é que neste caso o parâmetro que infere nos cálculos não é somente de um tipo, por exemplo em cálculo de descontos, onde há descontos de acordo com o valor da compra, quantidade de itens e etc o padrão chain of responsability é mais adequado https://refactoring.guru/design-patterns/chain-of-responsibility.
- Template Method: este padrão favorece o reaproveitamento de códigos comuns entre classes, evitando assim duplicações de códigos. https://refactoring.guru/design-patterns/template-method.
- State: esse padrão é utilizado quando temos uma transição de estados ou quando precisamos aplicar alguma regra ou algum algoritmo baseado em um estado de um objeto de uma classe. Ele é parecido com o Strategy https://refactoring.guru/design-patterns/state.
- Command: é um padrão que tem uma representação de um comando que precisa ser executado. Na realidade o padrão "Command" quando utilizado tem várias classes e cada uma delas vai ter um método em comum que é um método para executar alguma lógica https://refactoring.guru/design-patterns/command.
- Observer: é comumente utilizado por diversas bibliotecas que trabalham com eventos. Muitas tecnologias em Java, como o Spring e o CDI, possuem componentes que nos auxiliam a trabalhar com eventos https://refactoring.guru/design-patterns/observer.
